# Backend Service Development Guide

## üìã Overview

GigaPress Backend ServiceÎäî `source` ÎîîÎ†âÌÜ†Î¶¨Ïùò Îëê ÌëúÏ§Ä ÌîÑÎ°úÏ†ùÌä∏Î•º Í∏∞Î∞òÏúºÎ°ú Í∞úÎ∞úÎê©ÎãàÎã§:
- **ebmp-lib-common-module**: Í≥µÌÜµ ÎùºÏù¥Î∏åÎü¨Î¶¨ Î™®Îìà
- **ebmp-proj-standard-api**: ÌëúÏ§Ä ÌîÑÎ°úÏ†ùÌä∏ API ÌÖúÌîåÎ¶ø

Ïù¥ Í∞ÄÏù¥ÎìúÎäî ÌëúÏ§Ä Íµ¨Ï°∞ÏôÄ Ìå®ÌÑ¥ÏùÑ Ïú†ÏßÄÌïòÎ©¥ÏÑú GigaPress ÌäπÌôî ÎπÑÏ¶àÎãàÏä§ Î°úÏßÅÏùÑ Ï∂îÍ∞ÄÌïòÎäî Î∞©Î≤ïÏùÑ Ï†úÏãúÌï©ÎãàÎã§.

## üèóÔ∏è Architecture Overview

### ÌïòÏù¥Î∏åÎ¶¨Îìú ÏïÑÌÇ§ÌÖçÏ≤ò Ìå®ÌÑ¥

```
com.gigapress.backend/
‚îú‚îÄ‚îÄ common/              # Í≥µÌÜµ Î™®Îìà (ebmp-lib-common-module Í∏∞Î∞ò)
‚îú‚îÄ‚îÄ config/              # ÏÑ§Ï†ï ÌÅ¥ÎûòÏä§Îì§
‚îú‚îÄ‚îÄ security/            # JWT Í∏∞Î∞ò Ïù∏Ï¶ù/Ïù∏Í∞Ä
‚îú‚îÄ‚îÄ domain/              # ÎèÑÎ©îÏù∏Î≥Ñ Íµ¨Ï°∞
‚îÇ   ‚îú‚îÄ‚îÄ api/            # API ÏÉùÏÑ± ÎèÑÎ©îÏù∏ (DDD Ìå®ÌÑ¥)
‚îÇ   ‚îú‚îÄ‚îÄ project/        # ÌîÑÎ°úÏ†ùÌä∏ Í¥ÄÎ¶¨ ÎèÑÎ©îÏù∏ (DDD Ìå®ÌÑ¥)
‚îÇ   ‚îî‚îÄ‚îÄ template/       # ÌÖúÌîåÎ¶ø Í¥ÄÎ¶¨ ÎèÑÎ©îÏù∏ (MVC Ìå®ÌÑ¥)
‚îî‚îÄ‚îÄ infrastructure/      # Ïô∏Î∂Ä ÏãúÏä§ÌÖú Ïó∞Îèô
    ‚îú‚îÄ‚îÄ domain-schema/   # Domain Schema Service Ïó∞Îèô
    ‚îî‚îÄ‚îÄ kafka/          # Kafka Î©îÏãúÏßÄ Ï≤òÎ¶¨
```

## üîß Core Dependencies

### build.gradle Í∏∞Î≥∏ Íµ¨ÏÑ±

```gradle
plugins {
    id 'java'
    id 'org.springframework.boot' version '3.2.2'
    id 'io.spring.dependency-management' version '1.1.4'
}

group = 'com.gigapress'
version = '1.0.0'
sourceCompatibility = '17'

dependencies {
    // ebmp-lib-common-module ÏùòÏ°¥ÏÑ±
    implementation project(':ebmp-lib-common-module')
    
    // Spring Boot Core
    implementation 'org.springframework.boot:spring-boot-starter-web'
    implementation 'org.springframework.boot:spring-boot-starter-data-jpa'
    implementation 'org.springframework.boot:spring-boot-starter-security'
    implementation 'org.springframework.boot:spring-boot-starter-validation'
    implementation 'org.springframework.boot:spring-boot-starter-actuator'
    implementation 'org.springframework.boot:spring-boot-starter-data-redis'
    
    // QueryDSL
    implementation 'com.querydsl:querydsl-jpa:5.0.0:jakarta'
    annotationProcessor 'com.querydsl:querydsl-apt:5.0.0:jakarta'
    
    // JWT
    implementation 'io.jsonwebtoken:jjwt-api:0.11.5'
    runtimeOnly 'io.jsonwebtoken:jjwt-impl:0.11.5'
    runtimeOnly 'io.jsonwebtoken:jjwt-jackson:0.11.5'
    
    // Kafka
    implementation 'org.springframework.kafka:spring-kafka'
    
    // Database
    runtimeOnly 'org.postgresql:postgresql'
    
    // OpenAPI Documentation
    implementation 'org.springdoc:springdoc-openapi-starter-webmvc-ui:2.3.0'
    
    // Test Dependencies
    testImplementation 'org.springframework.boot:spring-boot-starter-test'
    testImplementation 'org.springframework.kafka:spring-kafka-test'
}
```

## üì¶ Package Structure

### 1. Common Î™®Îìà Íµ¨Ï°∞

```java
// BaseEntity ÏÉÅÏÜç ÏÇ¨Ïö©
@Entity
@Table(name = "api_specifications")
public class ApiSpecification extends BaseEntity {
    @Id
    @GeneratedValue(generator = "common-id")
    private Long id;
    
    private String name;
    private String description;
    // ... ÎπÑÏ¶àÎãàÏä§ ÌïÑÎìúÎì§
}
```

### 2. Security ÏÑ§Ï†ï

```java
@Configuration
@EnableWebSecurity
@EnableMethodSecurity
public class SecurityConfig {
    
    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        return http
            .csrf(csrf -> csrf.disable())
            .sessionManagement(session -> 
                session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
            .authorizeHttpRequests(auth -> auth
                .requestMatchers("/api/v1/auth/**").permitAll()
                .requestMatchers("/api/v1/public/**").permitAll()
                .requestMatchers("/actuator/**").permitAll()
                .anyRequest().authenticated())
            .addFilterBefore(jwtAuthenticationFilter(), 
                UsernamePasswordAuthenticationFilter.class)
            .build();
    }
}
```

### 3. Domain Íµ¨Ï°∞ (DDD Ìå®ÌÑ¥)

#### API Generation Domain ÏòàÏãú

```java
// 1. Domain Entity
@Entity
@Table(name = "api_specifications")
public class ApiSpecification extends BaseEntity {
    @Id
    @GeneratedValue(generator = "common-id")
    private Long id;
    
    @Column(nullable = false)
    private String projectId;
    
    @Enumerated(EnumType.STRING)
    private ApiType apiType;
    
    @Embedded
    private ApiMetadata metadata;
    
    // Domain methods
    public GeneratedApi generateApi(ApiPattern pattern) {
        // ÎπÑÏ¶àÎãàÏä§ Î°úÏßÅ
        return new GeneratedApi(this, pattern);
    }
}

// 2. Command/Info Í∞ùÏ≤¥
public class ApiSpecificationCommand {
    @NotBlank
    private String projectId;
    
    @NotNull
    private ApiType apiType;
    
    private ApiMetadata metadata;
    
    // getters/setters
}

public class ApiSpecificationInfo {
    private Long id;
    private String projectId;
    private ApiType apiType;
    private LocalDateTime createdAt;
    
    // getters
}

// 3. Domain Service
@Service
@Transactional
public class ApiSpecificationService {
    
    private final ApiSpecificationReader reader;
    private final ApiSpecificationStore store;
    private final ApiPatternService patternService;
    
    public ApiSpecificationInfo createApiSpecification(ApiSpecificationCommand command) {
        // ÎèÑÎ©îÏù∏ Î°úÏßÅ
        var specification = ApiSpecification.builder()
            .projectId(command.getProjectId())
            .apiType(command.getApiType())
            .metadata(command.getMetadata())
            .build();
            
        var saved = store.save(specification);
        return ApiSpecificationInfo.from(saved);
    }
    
    public GeneratedApi generateApi(Long specificationId, ApiPattern pattern) {
        var specification = reader.getById(specificationId);
        return specification.generateApi(pattern);
    }
}

// 4. Repository Interface (Domain Layer)
public interface ApiSpecificationReader {
    ApiSpecification getById(Long id);
    List<ApiSpecification> getByProjectId(String projectId);
    Page<ApiSpecification> getPage(Pageable pageable);
}

public interface ApiSpecificationStore {
    ApiSpecification save(ApiSpecification specification);
    void delete(Long id);
}

// 5. Repository Implementation (Infrastructure Layer)
@Repository
@Transactional(readOnly = true)
public class ApiSpecificationReaderImpl implements ApiSpecificationReader {
    
    private final ApiSpecificationRepository repository;
    private final JPAQueryFactory queryFactory;
    
    @Override
    public ApiSpecification getById(Long id) {
        return repository.findById(id)
            .orElseThrow(() -> new EntityNotFoundException("ApiSpecification", id));
    }
    
    @Override
    public List<ApiSpecification> getByProjectId(String projectId) {
        QApiSpecification spec = QApiSpecification.apiSpecification;
        
        return queryFactory
            .selectFrom(spec)
            .where(spec.projectId.eq(projectId)
                .and(spec.useYn.isTrue()))
            .orderBy(spec.frstRgstDt.desc())
            .fetch();
    }
}

// 6. Application Service (Facade)
@Service
@Transactional
public class ApiGenerationFacade {
    
    private final ApiSpecificationService specificationService;
    private final ApiTemplateService templateService;
    private final DomainSchemaServiceClient domainSchemaClient;
    private final KafkaProducerService kafkaProducer;
    
    public ApiGenerationResult generateApiFromSpec(ApiGenerationCommand command) {
        try {
            // 1. Domain Schema Ï°∞Ìöå
            var domainModel = domainSchemaClient.getDomainModel(command.getProjectId());
            
            // 2. API Ïä§Ìéô ÏÉùÏÑ±
            var specCommand = ApiSpecificationCommand.builder()
                .projectId(command.getProjectId())
                .apiType(command.getApiType())
                .metadata(ApiMetadata.from(domainModel))
                .build();
                
            var specification = specificationService.createApiSpecification(specCommand);
            
            // 3. ÌÖúÌîåÎ¶ø Í∏∞Î∞ò API ÏÉùÏÑ±
            var pattern = templateService.getApiPattern(command.getApiType());
            var generatedApi = specificationService.generateApi(specification.getId(), pattern);
            
            // 4. Í≤∞Í≥º Ïù¥Î≤§Ìä∏ Î∞úÌñâ
            kafkaProducer.publishApiGeneratedEvent(
                ApiGeneratedEvent.builder()
                    .specificationId(specification.getId())
                    .projectId(command.getProjectId())
                    .generatedFiles(generatedApi.getFiles())
                    .build()
            );
            
            return ApiGenerationResult.success(specification, generatedApi);
            
        } catch (Exception e) {
            log.error("API ÏÉùÏÑ± Ïã§Ìå®: {}", e.getMessage(), e);
            return ApiGenerationResult.failure(e.getMessage());
        }
    }
}

// 7. Controller (Interface Layer)
@RestController
@RequestMapping("/api/v1/api-generation")
@RequiredArgsConstructor
@Validated
public class ApiGenerationController extends BaseController {
    
    private final ApiGenerationFacade apiGenerationFacade;
    
    @PostMapping
    @Operation(summary = "API ÏÉùÏÑ±", description = "ÌîÑÎ°úÏ†ùÌä∏Ïùò ÎèÑÎ©îÏù∏ Î™®Îç∏ÏùÑ Í∏∞Î∞òÏúºÎ°ú APIÎ•º ÏÉùÏÑ±Ìï©ÎãàÎã§.")
    public ResultModel<ApiGenerationResponse> generateApi(
            @Valid @RequestBody ApiGenerationRequest request) {
        
        var command = ApiGenerationCommand.builder()
            .projectId(request.getProjectId())
            .apiType(request.getApiType())
            .templateId(request.getTemplateId())
            .build();
            
        var result = apiGenerationFacade.generateApiFromSpec(command);
        
        if (result.isSuccess()) {
            var response = ApiGenerationResponse.from(result);
            return ResultModel.success(response);
        } else {
            return ResultModel.error(ErrorCode.API_GENERATION_FAILED, result.getErrorMessage());
        }
    }
    
    @GetMapping("/{projectId}/specifications")
    @Operation(summary = "API Ïä§Ìéô Î™©Î°ù Ï°∞Ìöå")
    public ResultModel<List<ApiSpecificationResponse>> getApiSpecifications(
            @PathVariable String projectId) {
        
        var specifications = apiGenerationFacade.getApiSpecifications(projectId);
        var responses = specifications.stream()
            .map(ApiSpecificationResponse::from)
            .toList();
            
        return ResultModel.success(responses);
    }
}
```

### 4. Configuration ÏÑ§Ï†ï

```java
// Application Î©îÏù∏ ÌÅ¥ÎûòÏä§
@SpringBootApplication
@EnableJpaAuditing
@EnableKafka
@EnableScheduling
@EnableAsync
public class BackendServiceApplication {
    public static void main(String[] args) {
        SpringApplication.run(BackendServiceApplication.class, args);
    }
}

// Kafka ÏÑ§Ï†ï
@Configuration
@EnableKafka
@RequiredArgsConstructor
public class KafkaConfig {
    
    @Value("${spring.kafka.bootstrap-servers}")
    private String bootstrapServers;
    
    @Bean
    public ProducerFactory<String, Object> producerFactory() {
        Map<String, Object> configProps = new HashMap<>();
        configProps.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServers);
        configProps.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, StringSerializer.class);
        configProps.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, JsonSerializer.class);
        return new DefaultKafkaProducerFactory<>(configProps);
    }
    
    @Bean
    public KafkaTemplate<String, Object> kafkaTemplate() {
        return new KafkaTemplate<>(producerFactory());
    }
}

// External Client ÏÑ§Ï†ï
@FeignClient(name = "domain-schema-service", url = "${external.domain-schema.url}")
public interface DomainSchemaServiceClient {
    
    @GetMapping("/api/v1/domain-models/{projectId}")
    DomainModelResponse getDomainModel(@PathVariable String projectId);
    
    @PostMapping("/api/v1/domain-models/{projectId}/analyze")
    AnalysisResultResponse analyzeDomainModel(
        @PathVariable String projectId,
        @RequestBody AnalyzeRequest request
    );
}
```

## üîÑ Event-Driven Architecture

### Kafka Event Ï≤òÎ¶¨

```java
// Event Ï†ïÏùò
@JsonInclude(JsonInclude.Include.NON_NULL)
public class ApiGeneratedEvent {
    private Long specificationId;
    private String projectId;
    private List<GeneratedFile> generatedFiles;
    private LocalDateTime generatedAt;
    
    // builder pattern
}

// Event Producer
@Service
@RequiredArgsConstructor
public class KafkaProducerService {
    
    private final KafkaTemplate<String, Object> kafkaTemplate;
    
    public void publishApiGeneratedEvent(ApiGeneratedEvent event) {
        kafkaTemplate.send("api.generated", event.getProjectId(), event);
    }
}

// Event Consumer
@Service
@KafkaListener(topics = "domain.model.updated")
public class DomainModelEventConsumer {
    
    private final ApiSpecificationService apiSpecificationService;
    
    @KafkaHandler
    public void handle(DomainModelUpdatedEvent event) {
        log.info("ÎèÑÎ©îÏù∏ Î™®Îç∏ ÏóÖÎç∞Ïù¥Ìä∏ Ïù¥Î≤§Ìä∏ ÏàòÏã†: {}", event.getProjectId());
        
        // Í¥ÄÎ†® API Ïä§ÌéôÎì§ ÏóÖÎç∞Ïù¥Ìä∏
        apiSpecificationService.updateSpecificationsForProject(event.getProjectId());
    }
}
```

## üß™ Testing Strategy

### ÌÖåÏä§Ìä∏ Íµ¨Ï°∞

```java
// ÌÜµÌï© ÌÖåÏä§Ìä∏
@SpringBootTest
@Transactional
@TestPropertySource(properties = {
    "spring.kafka.bootstrap-servers=${spring.embedded.kafka.brokers}",
    "external.domain-schema.url=http://localhost:${wiremock.server.port}"
})
@EmbeddedKafka(partitions = 1, topics = {"api.generated", "domain.model.updated"})
class ApiGenerationIntegrationTest {
    
    @Autowired
    private ApiGenerationFacade apiGenerationFacade;
    
    @RegisterExtension
    static WireMockExtension wireMock = WireMockExtension.newInstance()
        .options(wireMockConfig().port(8089))
        .build();
    
    @Test
    void shouldGenerateApiSuccessfully() {
        // Given
        wireMock.stubFor(get(urlPathMatching("/api/v1/domain-models/.*"))
            .willReturn(aResponse()
                .withStatus(200)
                .withHeader("Content-Type", "application/json")
                .withBody(readTestResource("domain-model-response.json"))));
        
        var command = ApiGenerationCommand.builder()
            .projectId("test-project")
            .apiType(ApiType.REST_API)
            .build();
        
        // When
        var result = apiGenerationFacade.generateApiFromSpec(command);
        
        // Then
        assertThat(result.isSuccess()).isTrue();
        assertThat(result.getSpecification()).isNotNull();
        assertThat(result.getGeneratedApi().getFiles()).isNotEmpty();
    }
}

// Îã®ÏúÑ ÌÖåÏä§Ìä∏
@ExtendWith(MockitoExtension.class)
class ApiSpecificationServiceTest {
    
    @Mock
    private ApiSpecificationReader reader;
    
    @Mock
    private ApiSpecificationStore store;
    
    @InjectMocks
    private ApiSpecificationService service;
    
    @Test
    void shouldCreateApiSpecification() {
        // Given
        var command = ApiSpecificationCommand.builder()
            .projectId("test-project")
            .apiType(ApiType.REST_API)
            .build();
        
        var specification = ApiSpecification.builder()
            .id(1L)
            .projectId(command.getProjectId())
            .apiType(command.getApiType())
            .build();
        
        when(store.save(any(ApiSpecification.class))).thenReturn(specification);
        
        // When
        var result = service.createApiSpecification(command);
        
        // Then
        assertThat(result.getId()).isEqualTo(1L);
        assertThat(result.getProjectId()).isEqualTo("test-project");
        verify(store).save(any(ApiSpecification.class));
    }
}
```

## üìä Monitoring & Observability

### Actuator ÏÑ§Ï†ï

```yaml
# application.yml
management:
  endpoints:
    web:
      exposure:
        include: health,info,metrics,prometheus,kafka
  endpoint:
    health:
      show-details: always
  metrics:
    export:
      prometheus:
        enabled: true
```

### Custom Health Indicators

```java
@Component
public class DomainSchemaServiceHealthIndicator implements HealthIndicator {
    
    private final DomainSchemaServiceClient client;
    
    @Override
    public Health health() {
        try {
            // Ìó¨Ïä§Ï≤¥ÌÅ¨ Ìò∏Ï∂ú
            client.healthCheck();
            return Health.up()
                .withDetail("domain-schema-service", "Available")
                .build();
        } catch (Exception e) {
            return Health.down()
                .withDetail("domain-schema-service", "Unavailable")
                .withDetail("error", e.getMessage())
                .build();
        }
    }
}
```

## üöÄ Deployment

### Docker Configuration

```dockerfile
FROM openjdk:17-jre-slim

WORKDIR /app

COPY build/libs/backend-service-*.jar app.jar

EXPOSE 8084

ENTRYPOINT ["java", "-jar", "app.jar"]
```

### Kubernetes Deployment

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: backend-service
spec:
  replicas: 2
  selector:
    matchLabels:
      app: backend-service
  template:
    metadata:
      labels:
        app: backend-service
    spec:
      containers:
      - name: backend-service
        image: gigapress/backend-service:latest
        ports:
        - containerPort: 8084
        env:
        - name: SPRING_PROFILES_ACTIVE
          value: "prod"
        - name: SPRING_DATASOURCE_URL
          valueFrom:
            secretKeyRef:
              name: database-secret
              key: url
```

## üìù Development Guidelines

### 1. ÏΩîÎî© Ïª®Î≤§ÏÖò
- **Package Naming**: `com.gigapress.backend.domain.[ÎèÑÎ©îÏù∏Î™Ö]`
- **Class Naming**: 
  - Entity: `[DomainName]`
  - Service: `[DomainName]Service`
  - Controller: `[DomainName]Controller`
  - Repository: `[DomainName]Repository`

### 2. API ÏÑ§Í≥Ñ ÏõêÏπô
- **RESTful API**: HTTP MethodÏôÄ ÏÉÅÌÉúÏΩîÎìú Ï§ÄÏàò
- **Î≤ÑÏ†Ñ Í¥ÄÎ¶¨**: `/api/v1/` prefix ÏÇ¨Ïö©
- **ÏùëÎãµ ÌòïÏãù**: `ResultModel<T>` ÎûòÌïë
- **ÏóêÎü¨ Ï≤òÎ¶¨**: ÌëúÏ§ÄÌôîÎêú ErrorCode ÏÇ¨Ïö©

### 3. Î≥¥Ïïà Í∞ÄÏù¥ÎìúÎùºÏù∏
- **JWT ÌÜ†ÌÅ∞**: Î™®Îì† API Ïù∏Ï¶ù ÌïÑÏàò
- **ÏûÖÎ†• Í≤ÄÏ¶ù**: `@Valid`, `@Validated` ÏÇ¨Ïö©
- **SQL Injection**: QueryDSL ÏÇ¨Ïö©ÏúºÎ°ú Î∞©ÏßÄ
- **ÎØºÍ∞ê Ï†ïÎ≥¥**: ÌôòÍ≤ΩÎ≥ÄÏàòÎÇò Vault ÏÇ¨Ïö©

### 4. ÏÑ±Îä• ÏµúÏ†ÅÌôî
- **N+1 Î¨∏Ï†ú**: `@EntityGraph`, `fetch join` ÌôúÏö©
- **Ï∫êÏã±**: Redis Ï∫êÏãú Ï†ÅÍ∑π ÌôúÏö©
- **ÎπÑÎèôÍ∏∞ Ï≤òÎ¶¨**: `@Async`, Kafka Ïù¥Î≤§Ìä∏ ÌôúÏö©
- **Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§**: Ïù∏Îç±Ïä§ ÏµúÏ†ÅÌôî

## üîó Integration Points

### 1. Domain Schema Service
- **Ïö©ÎèÑ**: ÎèÑÎ©îÏù∏ Î™®Îç∏ Ï°∞Ìöå/Î∂ÑÏÑù
- **ÌîÑÎ°úÌÜ†ÏΩú**: HTTP REST API
- **Ïù∏Ï¶ù**: JWT ÌÜ†ÌÅ∞ Ï†ÑÎã¨

### 2. Conversational AI Engine
- **Ïö©ÎèÑ**: AI Í∏∞Î∞ò ÏΩîÎìú ÏÉùÏÑ± ÏöîÏ≤≠
- **ÌîÑÎ°úÌÜ†ÏΩú**: WebSocket ÎòêÎäî HTTP
- **Îç∞Ïù¥ÌÑ∞**: JSON ÌòïÏãù

### 3. Kafka Message Broker
- **Topics**: 
  - `api.generated`: API ÏÉùÏÑ± ÏôÑÎ£å Ïù¥Î≤§Ìä∏
  - `domain.model.updated`: ÎèÑÎ©îÏù∏ Î™®Îç∏ Î≥ÄÍ≤Ω Ïù¥Î≤§Ìä∏
  - `project.created`: ÌîÑÎ°úÏ†ùÌä∏ ÏÉùÏÑ± Ïù¥Î≤§Ìä∏

Ïù¥ Í∞ÄÏù¥ÎìúÎ•º Îî∞Îùº Í∞úÎ∞úÌïòÎ©¥ Í∏∞Ï°¥ ÌëúÏ§Ä ÌîÑÎ°úÏ†ùÌä∏Ïùò Í≤ÄÏ¶ùÎêú Ìå®ÌÑ¥Í≥º Íµ¨Ï°∞Î•º Ïú†ÏßÄÌïòÎ©¥ÏÑú GigaPressÎßåÏùò ÎπÑÏ¶àÎãàÏä§ Î°úÏßÅÏùÑ Ìö®Í≥ºÏ†ÅÏúºÎ°ú Íµ¨ÌòÑÌï† Ïàò ÏûàÏäµÎãàÎã§.